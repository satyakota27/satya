require 'csv' unless defined?(CSV)

class InventoryCsvImporter
  attr_reader :file, :user, :errors, :success_count, :failure_count

  def initialize(file, user)
    @file = file
    @user = user
    @errors = []
    @success_count = 0
    @failure_count = 0
  end

  def import
    return { success_count: 0, failure_count: 0, errors: ['No file provided'] } unless file.present?

    line_number = 1
    file_content = file.respond_to?(:read) ? file.read : file
    CSV.parse(file_content, headers: true) do |row|
      line_number += 1
      import_row(row, line_number)
    end

    { success_count: @success_count, failure_count: @failure_count, errors: @errors }
  end

  def self.generate_template
    CSV.generate(headers: true) do |csv|
      csv << ['material_code', 'quantity', 'location_path', 
              'legacy_serial_id', 'legacy_batch_number', 'notes', 'purchase_date', 
              'expiry_date', 'cost', 'supplier']
      csv << ['M-ACME-1', '1', 'USA/NewYork/Building1/ZoneA', 
              'OLD-SN-001', '', 'Sample inventory item', '2024-01-15', 
              '2025-01-15', '100.50', 'Supplier ABC']
    end
  end

  private

  def import_row(row, line_number)
    material = find_material(row['material_code'])
    return add_error("Row #{line_number}: Material not found or not approved") unless material&.approved?

    warehouse_location = find_location(row['location_path']) if row['location_path'].present?

    inventory_item = InventoryItem.new(
      material: material,
      warehouse_location: warehouse_location,
      quantity: row['quantity'].presence&.to_i || 1,
      legacy_serial_id: row['legacy_serial_id'].presence,
      legacy_batch_number: row['legacy_batch_number'].presence,
      notes: row['notes'].presence,
      purchase_date: parse_date(row['purchase_date']),
      expiry_date: parse_date(row['expiry_date']),
      cost: parse_decimal(row['cost']),
      supplier: row['supplier'].presence,
      tenant: user.tenant,
      created_by: user
    )
    # serial_number and batch_number will be auto-generated by the model's before_validation callback

    if inventory_item.save
      @success_count += 1
    else
      @failure_count += 1
      add_error("Row #{line_number}: #{inventory_item.errors.full_messages.join(', ')}")
    end
  rescue => e
    @failure_count += 1
    add_error("Row #{line_number}: #{e.message}")
  end

  def find_material(material_code)
    return nil if material_code.blank?
    Material.find_by(material_code: material_code, state: 'approved')
  end

  def find_location(location_path)
    return nil if location_path.blank?

    # Try to find by full path (split by "/" and traverse hierarchy)
    parts = location_path.split('/').map(&:strip).reject(&:blank?)
    return nil if parts.empty?

    # Start from root locations
    current = WarehouseLocation.roots.where(location_code: parts.first).first
    return nil unless current

    # Traverse the path
    parts[1..-1].each do |part|
      current = current.children.find_by(location_code: part)
      return nil unless current
    end

    current
  end

  def parse_date(date_string)
    return nil if date_string.blank?
    Date.parse(date_string)
  rescue
    nil
  end

  def parse_decimal(decimal_string)
    return nil if decimal_string.blank?
    BigDecimal(decimal_string)
  rescue
    nil
  end

  def add_error(message)
    @errors << message
    @errors = @errors.last(100) # Limit to last 100 errors
  end
end

